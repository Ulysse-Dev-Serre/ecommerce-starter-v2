import { test, expect } from '@playwright/test';
import { LogisticsPage } from '../pom/admin/LogisticsPage';
import { ProductPage } from '../pom/admin/ProductPage';
import { prisma } from '@/lib/core/db';
import { verifyProductCreated } from '../fixtures/seed-test-data';
import { cleanupOrphanedAttributes } from '@/lib/services/attributes/attribute-cleanup.service';
import { cleanupAllE2EData, disconnectPrisma } from '../fixtures/cleanup-e2e';

test.describe('Admin Logistics & Product Workflow', () => {
  // Tests in this file are dependent on each other
  test.describe.configure({ mode: 'serial' });

  // Test Data
  const timestamp = Date.now();

  // Logistics Data
  const locationName = `E2E Warehouse ${timestamp}`;
  const locationData = {
    name: locationName,
    type: 'LOCAL_STOCK',
    incoterm: 'DDP',
    address: {
      name: 'E2E Sender',
      street1: '123 Test St',
      city: 'Montreal',
      state: 'QC',
      zip: 'H3Z 2Y7',
      country: 'CA',
      email: 'test@example.com',
      phone: '5145550123',
    },
  };

  // Product Data
  const productName = `E2E Product ${timestamp}`;

  // Setup: Ensure clean state
  test.beforeAll(async () => {
    try {
      await prisma.supplier.deleteMany({
        where: { name: { contains: 'E2E' } },
      });
      // Product name is in translations, so we delete by slug convention or relation
      await prisma.product.deleteMany({
        where: { slug: { contains: 'e2e-product' } },
      });
      console.log('ðŸ§¹ Cleaned up old E2E data');
    } catch (e) {
      console.error('âš ï¸ Cleanup warning:', e);
    }
  });

  // Verify Teardown
  test.afterAll(async () => {
    try {
      await prisma.supplier.deleteMany({
        where: { name: locationName },
      });
      await prisma.product.deleteMany({
        where: { slug: { contains: 'e2e-product' } },
      });

      // Nettoyage automatique des attributs orphelins
      await cleanupOrphanedAttributes();

      console.log('ðŸ§¹ Teardown complete');
    } catch (e) {
      console.error('âš ï¸ Teardown warning:', e);
    }
  });

  test('Create Logistics Location (Supplier)', async ({ page }) => {
    const logistics = new LogisticsPage(page);

    // 1. Navigate
    await logistics.goto();

    // 2. Open Modal
    await logistics.openAddLocationModal();

    // 3. Fill Form
    await logistics.fillLocationForm(locationData);

    // 4. Save
    await logistics.save();

    // 5. Verify Success (UI)
    await logistics.expectLocationCreated(locationName);

    // 6. Verify Data Consistency (API Contract)
    await test.step('Verify DB Creation (API Contract)', async () => {
      const supplier = await prisma.supplier.findFirst({
        where: { name: locationName },
      });
      expect(supplier).not.toBeNull();
      expect(supplier?.type).toBe('LOCAL_STOCK');
    });
  });

  test('Create Product (Draft)', async ({ page }) => {
    const products = new ProductPage(page);

    // 1. Navigate to Create
    await products.gotoCreate();
    await products.expectLoaded();

    // 2. Create Basic Draft
    await products.createDraftProduct(productName, locationName);

    // 3. Verify Redirection to Edit Page (implicitly checked in createDraftProduct via waitForURL)

    // 4. Verify DB State (API Contract)
    await test.step('Verify Product Created in DB', async () => {
      const product = await prisma.product.findFirst({
        where: { slug: { contains: `e2e-product-${timestamp}` } },
      });

      if (!product) {
        const allProducts = await prisma.product.findMany({
          take: 10,
          orderBy: { createdAt: 'desc' },
        });
        console.log(
          'âŒ Product not found by slug. Latest products in DB:',
          allProducts.map(p => ({ slug: p.slug, id: p.id }))
        );
      }

      expect(product).not.toBeNull();
      expect(product?.status).toBe('DRAFT');
    });
  });

  test('Publish and Verify Storefront', async ({ page }) => {
    const products = new ProductPage(page);

    // Use the product created in previous test
    // We need to navigate to its edit page. Since tests are isolated, we rely on the URL structure or list page.
    // For simplicity/robustness in this flow, we assume we are continuing or can navigate.
    // Best practice: Query DB to get ID/Slug
    const product = await prisma.product.findFirst({
      where: { slug: { contains: `e2e-product-${timestamp}` } },
    });
    expect(product).not.toBeNull();

    await test.step('Navigate to Edit Page', async () => {
      await page.goto(`/en/admin/products/${product?.id}/edit`);
    });

    // 1. Add Variant (Price & Stock)
    // Note: SKU is auto-generated by backend based on Slug and Name
    await products.addVariant('99.99', '50');

    // Final save for the whole product status/logistics
    await products.saveButton.click();
    // Give it a moment or wait for response (addVariant might need enhancement if separate save is needed)

    // 2. Publish
    await products.publish();

    // 3. Verify Active Status in DB (with Polling)
    // const { verifyProductCreated } = require('../../fixtures/seed-test-data');

    await test.step('Verify Product Active in DB', async () => {
      const activeProduct = await verifyProductCreated(product!.slug, 'ACTIVE');
      if (!activeProduct) {
        throw new Error(
          `âŒ Product ${product!.slug} did not become ACTIVE in DB.`
        );
      }
      expect(activeProduct.status).toBe('ACTIVE');
    });

    // 4. Storefront Verification
    await test.step('Verify Storefront Access', async () => {
      // Optional: Add a small delay to ensure ISR/Revalidation is done
      // await page.waitForTimeout(1000);
      await products.verifyStorefront(product!.slug);
    });
  });
});
