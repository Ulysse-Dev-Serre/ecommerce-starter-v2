import { NextRequest, NextResponse } from 'next/server';

import { ProductStatus, Language } from '../../../../generated/prisma';
import { logger } from '../../../../lib/logger';
import { withAdmin } from '../../../../lib/middleware/withAuth';
import { withError } from '../../../../lib/middleware/withError';
import {
  deleteProduct,
  getProductByIdSimple,
  getProductBySlug,
  isProductAvailable,
} from '../../../../lib/services/product.service';

async function deleteProductHandler(
  _request: Request,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse> {
  const { id } = await params;

  logger.info(
    { action: 'delete_product', productId: id },
    `Processing deletion for product ${id}`
  );

  const product = await getProductByIdSimple(id);
  if (!product) {
    logger.warn(
      { action: 'delete_product_not_found', productId: id },
      `Product ${id} not found`
    );
    return NextResponse.json(
      { success: false, error: 'Product not found' },
      { status: 404 }
    );
  }

  const deletedProduct = await deleteProduct(id);

  logger.info(
    {
      action: 'product_deleted_successfully',
      productId: id,
      slug: deletedProduct.slug,
    },
    `Product deleted successfully: ${deletedProduct.slug}`
  );

  return NextResponse.json({
    success: true,
    product: deletedProduct,
    message: 'Product deleted successfully',
    timestamp: new Date().toISOString(),
  });
}

async function getProductHandler(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
): Promise<NextResponse> {
  const requestId = crypto.randomUUID();
  const { id } = await params;
  const { searchParams } = new URL(request.url);

  const language = searchParams.get('language') as Language | null;

  logger.info(
    {
      requestId,
      action: 'get_product',
      id,
      language,
    },
    `Fetching product: ${id}`
  );

  // Try slug first (returns full ProductProjection)
  const product = await getProductBySlug(id, language ?? undefined);

  if (!product) {
    logger.warn(
      {
        requestId,
        action: 'product_not_found',
        id,
      },
      `Product not found: ${id}`
    );

    return NextResponse.json(
      {
        success: false,
        requestId,
        error: 'Product not found',
        timestamp: new Date().toISOString(),
      },
      {
        status: 404,
        headers: {
          'X-Request-ID': requestId,
        },
      }
    );
  }

  const isAvailable = isProductAvailable(product);
  const isDraft = product.status === ProductStatus.DRAFT;
  const hasStock = product.variants.some(
    v => v.inventory && v.inventory.stock > 0
  );

  logger.info(
    {
      requestId,
      action: 'product_fetched_successfully',
      id,
      productId: product.id,
      status: product.status,
      isAvailable,
      hasStock,
      variantsCount: product.variants.length,
    },
    `Product retrieved: ${id}`
  );

  const response: any = {
    success: true,
    requestId,
    data: product,
    meta: {
      isAvailable,
      isDraft,
      hasStock,
      variantsCount: product.variants.length,
    },
    timestamp: new Date().toISOString(),
  };

  if (isDraft) {
    response.meta.seoIndex = false;
  }

  if (!hasStock) {
    response.meta.stockStatus = 'out_of_stock';
  }

  return NextResponse.json(response, {
    headers: {
      'X-Request-ID': requestId,
    },
  });
}

export const GET = withError(getProductHandler);
export const DELETE = withError(withAdmin(deleteProductHandler));
