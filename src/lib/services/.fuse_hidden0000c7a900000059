import { Prisma, ProductStatus, Language, Product } from '../../generated/prisma';
import { prisma } from '../db/prisma';
import { logger } from '../logger';

export interface ProductListFilters {
  status?: ProductStatus;
  isFeatured?: boolean;
  categorySlug?: string;
  language?: Language;
  search?: string;
}

export interface ProductListOptions {
  page?: number;
  limit?: number;
  sortBy?: 'createdAt' | 'updatedAt' | 'name' | 'price';
  sortOrder?: 'asc' | 'desc';
}

export interface ProductVariantProjection {
  id: string;
  sku: string;
  pricing: {
    price: Prisma.Decimal;
    currency: string;
    priceType: string;
  }[];
  inventory: {
    stock: number;
    lowStockThreshold: number;
    trackInventory: boolean;
    allowBackorder: boolean;
  } | null;
  attributeValues: {
    attributeValue: {
      value: string;
      attribute: {
        key: string;
      };
      translations: {
        language: string;
        displayName: string;
      }[];
    };
  }[];
  media: {
    url: string;
    alt: string | null;
    isPrimary: boolean;
    sortOrder: number;
  }[];
}

export interface ProductProjection {
  id: string;
  slug: string;
  status: ProductStatus;
  isFeatured: boolean;
  createdAt: Date;
  updatedAt: Date;
  translations: {
    language: string;
    name: string;
    description: string | null;
    shortDescription: string | null;
  }[];
  variants: ProductVariantProjection[];
  categories: {
    category: {
      slug: string;
      translations: {
        language: string;
        name: string;
      }[];
    };
  }[];
  media: {
    url: string;
    alt: string | null;
    isPrimary: boolean;
    sortOrder: number;
  }[];
}

/**
 * Get products with pagination, filtering, and sorting
 */
export async function getProducts(
  filters: ProductListFilters = {},
  options: ProductListOptions = {}
): Promise<{
  products: ProductProjection[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}> {
  const page = options.page ?? 1;
  const limit = options.limit ?? 20;
  const skip = (page - 1) * limit;

  const where: any = {
    deletedAt: null,
  };

  if (filters.status) {
    where.status = filters.status;
  }

  if (filters.isFeatured !== undefined) {
    where.isFeatured = filters.isFeatured;
  }

  if (filters.categorySlug) {
    where.categories = {
      some: {
        category: {
          slug: filters.categorySlug,
        },
      },
    };
  }

  if (filters.search && filters.language) {
    where.translations = {
      some: {
        language: filters.language,
        OR: [
          { name: { contains: filters.search, mode: 'insensitive' } },
          { description: { contains: filters.search, mode: 'insensitive' } },
        ],
      },
    };
  }

  const orderBy: any = {};
  if (options.sortBy === 'name' && filters.language) {
    orderBy.translations = {
      _count: 'desc',
    };
  } else if (options.sortBy === 'price') {
    orderBy.variants = {
      _count: 'desc',
    };
  } else {
    orderBy[options.sortBy ?? 'createdAt'] = options.sortOrder ?? 'desc';
  }

  const [products, total] = await Promise.all([
    prisma.product.findMany({
      where,
      skip,
      take: limit,
      orderBy,
      select: {
        id: true,
        slug: true,
        status: true,
        isFeatured: true,
        createdAt: true,
        updatedAt: true,
        translations: {
          select: {
            language: true,
            name: true,
            description: true,
            shortDescription: true,
          },
        },
        variants: {
          where: { deletedAt: null },
          select: {
            id: true,
            sku: true,
            pricing: {
              where: { isActive: true },
              select: {
                price: true,
                currency: true,
                priceType: true,
              },
            },
            inventory: {
              select: {
                stock: true,
                lowStockThreshold: true,
                trackInventory: true,
                allowBackorder: true,
              },
            },
            attributeValues: {
              select: {
                attributeValue: {
                  select: {
                    value: true,
                    attribute: {
                      select: {
                        key: true,
                      },
                    },
                    translations: {
                      select: {
                        language: true,
                        displayName: true,
                      },
                    },
                  },
                },
              },
            },
            media: {
              select: {
                url: true,
                alt: true,
                isPrimary: true,
                sortOrder: true,
              },
              orderBy: {
                sortOrder: 'asc',
              },
            },
          },
        },
        categories: {
          select: {
            category: {
              select: {
                slug: true,
                translations: {
                  select: {
                    language: true,
                    name: true,
                  },
                },
              },
            },
          },
        },
        media: {
          where: {
            productId: { not: null },
          },
          select: {
            url: true,
            alt: true,
            isPrimary: true,
            sortOrder: true,
          },
          orderBy: {
            sortOrder: 'asc',
          },
        },
      },
    }),
    prisma.product.count({ where }),
  ]);

  const totalPages = Math.ceil(total / limit);

  logger.info(
    {
      action: 'products_fetched',
      filters,
      page,
      limit,
      total,
      count: products.length,
    },
    `Fetched ${products.length} products`
  );

  return {
    products: products as ProductProjection[],
    pagination: {
      page,
      limit,
      total,
      totalPages,
    },
  };
}

/**
 * Get product by slug with full details
 */
export async function getProductBySlug(
  slug: string,
  language?: Language
): Promise<ProductProjection | null> {
  const where: any = {
    slug,
    deletedAt: null,
  };

  const product = await prisma.product.findFirst({
    where,
    select: {
      id: true,
      slug: true,
      status: true,
      isFeatured: true,
      createdAt: true,
      updatedAt: true,
      translations: {
        where: language ? { language } : undefined,
        select: {
          language: true,
          name: true,
          description: true,
          shortDescription: true,
        },
      },
      variants: {
        where: { deletedAt: null },
        select: {
          id: true,
          sku: true,
          pricing: {
            where: { isActive: true },
            select: {
              price: true,
              currency: true,
              priceType: true,
            },
          },
          inventory: {
            select: {
              stock: true,
              lowStockThreshold: true,
              trackInventory: true,
              allowBackorder: true,
            },
          },
          attributeValues: {
            select: {
              attributeValue: {
                select: {
                  value: true,
                  attribute: {
                    select: {
                      key: true,
                    },
                  },
                  translations: {
                    where: language ? { language } : undefined,
                    select: {
                      language: true,
                      displayName: true,
                    },
                  },
                },
              },
            },
          },
          media: {
            select: {
              url: true,
              alt: true,
              isPrimary: true,
              sortOrder: true,
            },
            orderBy: {
              sortOrder: 'asc',
            },
          },
        },
      },
      categories: {
        select: {
          category: {
            select: {
              slug: true,
              translations: {
                where: language ? { language } : undefined,
                select: {
                  language: true,
                  name: true,
                },
              },
            },
          },
        },
      },
      media: {
        where: {
          productId: { not: null },
        },
        select: {
          url: true,
          alt: true,
          isPrimary: true,
          sortOrder: true,
        },
        orderBy: {
          sortOrder: 'asc',
        },
      },
    },
  });

  if (product) {
    logger.info(
      {
        action: 'product_fetched_by_slug',
        slug,
        productId: product.id,
        language,
      },
      `Product fetched: ${slug}`
    );
  } else {
    logger.warn(
      {
        action: 'product_not_found',
        slug,
      },
      `Product not found: ${slug}`
    );
  }

  return product as unknown as ProductProjection | null;
}

/**
 * Check if product is available for purchase
 */
export function isProductAvailable(product: ProductProjection): boolean {
  if (product.status !== ProductStatus.ACTIVE) {
    return false;
  }

  const hasStock = product.variants.some(variant => {
    if (!variant.inventory) return false;
    if (!variant.inventory.trackInventory) return true;
    if (variant.inventory.stock > 0) return true;
    return variant.inventory.allowBackorder;
  });

  return hasStock;
}

/**
 * Get product count for health checks
 */
export async function getProductCount(): Promise<number> {
  return prisma.product.count({
    where: {
      deletedAt: null,
    },
  });
}

export interface CreateProductData {
  slug: string;
  status?: ProductStatus;
  isFeatured?: boolean;
  sortOrder?: number;
  categoryId?: string;
  translations?: {
    language: Language;
    name: string;
    description?: string;
    shortDescription?: string;
    metaTitle?: string;
    metaDescription?: string;
  }[];
  variants?: {
    sku: string;
    price: number;
    stock: number;
    attributeValueIds?: string[];
  }[];
}

export interface UpdateProductData {
  slug?: string;
  status?: ProductStatus;
  isFeatured?: boolean;
  sortOrder?: number;
  categoryId?: string | null;
  translations?: {
    language: Language;
    name: string;
    description?: string;
    shortDescription?: string;
    metaTitle?: string;
    metaDescription?: string;
  }[];
  variants?: {
    sku: string;
    price: number;
    stock: number;
    attributeValueIds?: string[];
  }[];
}

type ProductWithTranslations = Product & {
  translations: {
    id: string;
    language: Language;
    name: string;
    description: string | null;
    shortDescription: string | null;
    metaTitle: string | null;
    metaDescription: string | null;
  }[];
};

/**
 * Get all products with translations (simple version for admin)
 */
export async function getAllProducts(): Promise<ProductWithTranslations[]> {
  return prisma.product.findMany({
    where: {
      deletedAt: null,
    },
    include: {
      translations: true,
    },
    orderBy: {
      createdAt: 'desc',
    },
  });
}

/**
 * Get product by ID (simple version for admin/delete)
 */
export async function getProductByIdSimple(
  id: string
): Promise<ProductWithTranslations | null> {
  return prisma.product.findFirst({
    where: {
      id,
      deletedAt: null,
    },
    include: {
      translations: true,
    },
  });
}

/**
 * Create new product
 */
export async function createProduct(
  productData: CreateProductData
): Promise<ProductWithTranslations> {
  const product = await prisma.product.create({
    data: {
      slug: productData.slug,
      status: productData.status ?? ProductStatus.DRAFT,
      isFeatured: productData.isFeatured ?? false,
      sortOrder: productData.sortOrder ?? 0,
      categories: productData.categoryId
        ? {
            create: {
              categoryId: productData.categoryId,
            },
          }
        : undefined,
      translations: productData.translations
        ? {
            create: productData.translations,
          }
        : undefined,
      variants: productData.variants
        ? {
            create: productData.variants.map(v => ({
              sku: v.sku,
              pricing: {
                create: {
                  priceType: 'base',
                  price: v.price,
                  currency: 'CAD',
                },
              },
              inventory: {
                create: {
                  stock: v.stock,
                  lowStockThreshold: 10,
                },
              },
              attributeValues: v.attributeValueIds
                ? {
                    create: v.attributeValueIds.map(valueId => ({
                      attributeValueId: valueId,
                    })),
                  }
                : undefined,
            })),
          }
        : undefined,
    },
    include: {
      translations: true,
    },
  });

  logger.info(
    {
      action: 'product_created',
      productId: product.id,
      slug: product.slug,
      variantsCount: productData.variants?.length ?? 0,
    },
    'Product created successfully'
  );

  return product;
}

/**
 * Update product
 */
export async function updateProduct(
  id: string,
  productData: UpdateProductData
): Promise<ProductWithTranslations> {
  const { translations, variants, categoryId, ...baseData } = productData;

  const updateData: any = {
    ...baseData,
    updatedAt: new Date(),
  };

  // Gérer les catégories
  if (categoryId !== undefined) {
    if (categoryId === null) {
      updateData.categories = { deleteMany: {} };
    } else {
      updateData.categories = {
        deleteMany: {},
        create: { categoryId },
      };
    }
  }

  // Gérer les traductions
  if (translations && translations.length > 0) {
    updateData.translations = {
      deleteMany: {},
      create: translations,
    };
  }

  // Gérer les variantes
  if (variants && variants.length > 0) {
    updateData.variants = {
      deleteMany: {},
      create: variants.map(v => ({
        sku: v.sku,
        pricing: {
          create: {
            priceType: 'base',
            price: v.price,
            currency: 'CAD',
          },
        },
        inventory: {
          create: {
            stock: v.stock,
            lowStockThreshold: 10,
          },
        },
        attributeValues: v.attributeValueIds
          ? {
              create: v.attributeValueIds.map(valueId => ({
                attributeValueId: valueId,
              })),
            }
          : undefined,
      })),
    };
  }

  const updatedProduct = await prisma.product.update({
    where: { id },
    data: updateData,
    include: {
      translations: true,
    },
  });

  logger.info(
    {
      action: 'product_updated',
      productId: id,
      slug: updatedProduct.slug,
      translationsUpdated: translations?.length ?? 0,
      variantsUpdated: variants?.length ?? 0,
    },
    'Product updated successfully'
  );

  return updatedProduct;
}

/**
 * Soft delete product
 */
export async function deleteProduct(id: string): Promise<Product> {
  const deletedProduct = await prisma.product.update({
    where: { id },
    data: {
      deletedAt: new Date(),
      updatedAt: new Date(),
    },
  });

  logger.info(
    {
      action: 'product_deleted',
      productId: id,
      slug: deletedProduct.slug,
    },
    'Product soft deleted successfully'
  );

  return deletedProduct;
}

/**
 * Hard delete product (for testing purposes)
 */
export async function hardDeleteProduct(id: string): Promise<Product> {
  const deletedProduct = await prisma.product.delete({
    where: { id },
  });

  logger.info(
    {
      action: 'product_hard_deleted',
      productId: id,
    },
    'Product hard deleted successfully'
  );

  return deletedProduct;
}
